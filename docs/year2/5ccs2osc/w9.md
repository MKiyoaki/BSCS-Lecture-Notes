## WEEK IX - Access Control

>[🏠 MENU - 5CCS2OSC](year2/5ccs2osc.md)
>
>[⬅️ WEEK XIII - User-Level Memory Allocation](year2/5ccs2osc/w8.md)
>
>[➡️ WEEK X - ](year2/5ccs2osc/w10.md)
>
>Outlines:
>
>

### 23. Introduction to Access Control

> ref:
>
> [访问控制一 - CSDN](https://blog.csdn.net/m0_50299484/article/details/115195576)

##### 23.1. System Defines Mechanism

- Introduction to Access Control Policy
  - File Sharing
    - File Sharing allows multiple users or processes to share with the same file, while the OS only need to keep a copy of it. 

    - Access to objects that may be shared is controlled by the OS. 

      > e.g.
      >
      > Alice can read Alice's mail, but Bob cannot. 

  - Motivation
    - Most modern operating systems are multi-user, that it gives processes a "user identity" so to support with file sharing. Abstractly, it is like a label denoting privilege. 
    - In order to prevent unauthorised modification to the files from other users, there is an **access control policy** that resolved with the permission problems of files, including the permission of r*ead, write and execute*, basing on that user identity. 

  - Access Control Policy

    - OSs aim to provide expressive mechanisms that can represent a range of policies. The specific policy is decided by the users of the system. 

      > e.g.
      >
      > Alice might create a file that anyone can read, but only she can write. 
      >
      > Alice might also create a file that both she and Bob can read and read, but others cannot access. 

    - Example design of Unix

      - In Unix, permission checking is done only at `open()`, if we want to `open()` a file by pathname, and then `read()` and `write()` on file handles. 

      - Permission bits

        - Structure

          > e.g.
          >
          > `alice@host $ ls -l ~/mail`
          >
          > `-rw-------- 1 alice alice 450871 Mar 4 2023 /home/alice/mail`

        - `rw-` - *owner* (`alice` in this example) can read and write but not execute

        - `---` - other members of the *group* `alice` can do nothing

        - `---` - other users can do nothing
      
          > e.g.
          >
          > `k2144518@5CCS2OSC: $ ls -ld /shared drwxr-xr-x 4 k2144518 nms_informatics_staff 4096 Mr 9 12:19 5CCS2OSC`

      - Properties

        - **Permission bits** are stored in a Unix filesystem data structure called the `inode` (~ one per file). 

          - After `open()`, having the file handle is enough. Checks are not done at `read()` or `write()`. 

          - However, file descriptors may be restricted at the time of `open()`. 
      
            > e.g.
            >
            > If we did `int fd = open("/home/alice/mail", O_RDONLY); `, then only `read()`, not `write()` will succeed on handle `fd`. 

      - This design means
      
        - Cost of checking is *amortised*
        - **Delegation** is possible, because it can even transmit `fd` to other proceses. 
        - But **revocation** is hard, since changing permissions doesn't revoke open `fds`. 

##### 23.2. Modelling Polices

- Access Control Matrix

  - We can draw a big table of who has what access to which object. 

    >     e.g.
    >
    >     |         | `/etc/passwd` | `/vmunix` | `/usr/bin/ls` | `/home/alice/project` |
    >     | ------- | ------------- | --------- | ------------- | --------------------- |
    >     | alice   | read          | -         | read, execute | read, write           |
    >     | bob     | read          | -         | read, execute | read, write           |
    >     | charlie | read          | -         | read, execute | -                     |
    >     | dave    | read          | -         | read, execute | -                     |

    - This is an **access control matrix**. 
    - For representing the matrix into data structures on a running system, we can 
      1. Store with each objects <u>in a list of pairs</u> *(who, what permission)*. These are **access control lists (ACLs)**. 
      2. Give each subject with <u>a list of pairs</u> *(which object, what access)*. Each of these paris is a **capability**, like a file descriptor. 

- Access control lists (ACLs)

  - Properties

    - Unix's `user`, `group`, `other` permission bits are a lmitied ACL. 
    - Full explicit ACLs can become <u>large (when added up) and performance-sensitive (if checks are frequent)</u>. 

  - ACL with objects

    - ACLs protect the object, at the object. 

      > e.g., Unix files at `open()` time. Each file has a (short) ACL. 

      - Pros ✅

        1. Easy to revoke, since just need to take name off the list
        2. Easy to understand audit

      - Cons ❌

        1. Scale can become a problem if there are many `{users, files, actions}`. 

           > e.g.
           >
           > Unix has many heuristics aimed at sensible ACL by default: current `uid/gid`, `umask`, `setgid` & sticky directories, etc. 

        2. **Authority** is ambiend, based on "who you are". It cannot *delegate fine-grained access* to some code/process. 

           > i.e., ACL is basing on the identification of user, so it can decide which user can access with which object, but cannot decide like the permission of some specific parts of code or processes. 

           > e.g.
           >
           > Not workable when ACLs with <u>distinct permissions for each process</u>. 

      > Problems will be more serious when distribution. 

- Capability lists

  - Properties

    - The descriptor encapsulates *which file* and *what access*. 
    - Specifically, store capabilities are not with each user but with <u>each process</u>, that enabling them to be *fine-grained* and *dynamic*. 

  - Capabilities with subject, active and maybe process

    - A capability is an unforgeable **token of authority** on some object. 

    - It is a pair of *<object reference, access rights>*. Possessing a valid reference is enough. 

      > e.g., File descripotrs. 
      >
      > - Kernel maintains table of valid `fds`
      > - Can delegate
      > - Hard to revoke

    - Capabilities deeply affect *how programs refer to protected objects*. 

      - Can be fine-grained. 
      - Designated, not ambient. 

      > Validation check can be distributed using cryptography. 


##### 23.3. Summary

| ACLs                            | Capabilities                                  |
| ------------------------------- | --------------------------------------------- |
| Stored with objects             | Stored with subjects                          |
| Check permissions on *access*   | Check permission on *issue + validity* on use |
| Easy to revoke                  | Hard to revoke                                |
| Hard to delegate                | Easy to delegate                              |
| Usually coarse-grained          | Easily made fine-grained                      |
| Easy to audit                   | Hard to audit *(e.g., following delegation)*  |
| Easy to retrofit                | Must usally "design in"                       |
| Tend to bottleneek distrubution | Distributes more scalably                     |
| Authority is ambient            | Authority is designated                       |

---

### 24. Definitions

##### 24.1. Security

- Security means adversarial

  - Security is a mindset of constant suspicion. (who/what am I forced to trust & who/what is trustworthy)

  - Security mechanisms must be designed for *'adversarial' situations*, i.e., someone is actively tryign to break them. 

    > Actually C, Unix, the Internet were not really designed like this. 

  - Security contrasts with fault-talerance

    - **Fault-tolerance** - Protecting processes (or other resources) <u>from accidental error</u> (e.g., Incompletence). 
    - **Security** - Protecting processes or other resources <u>from adversarial (malicious) behaviour</u>. 

    > The two are often conflated, but they differ in pratice. 

- Common kinds of security property

  - **Confidentiality** - Information is not *disclosed* to unintended parties. 

  - **Integrity** - Information is not *modifiable* by unintended parties (i.e., tamper-proof), or at least not without giveaway (i.e., tamper-evident). 

    > Modification includes unintended creatin, *e.g., of fake/spurious data*. 

  - **Availability** - Malicious actors cannot deprive others of the service (e.g., denail of service attck or `fork()` bomb. )

  - Notice that

    - These properties are only ever provided <u>up to certain assumptions (*attack model*) and budget (*attack resources*)</u>. 

      > e.g.
      >
      > Can an attcker break into your house
      >
      > Can an attacker plant agents in your orgranisation

    - These properties are almost always trade off against performance and convenience. 

##### 24.2. Security and Access Control

- Polices to formulate

  - Motivation
  	- We can formulate policies about **confidentiality** and **integraity**, like ACLs or capabilities. 
  	- To protect availability, i.e., prevent 'denial of service' attacks, we would need to add some kind of *resource limits*. 

    	> e.g. 
    	>
    	> Set a max {#processes, allocated physical memory, ...} per user. 
    	>
    	> Limit rate of process creation (or similar things) per user. 

  - Human bottleneck

    - Correctly enforcing policies is the easy part, while the following human problems is more serious. 

      - Getting plicies right. 
      - Mitigating when things go wrong (Swiss chesse layers). 
      - Bootstrapping the user notation, i.e., authentication. 

    - Complexity birngs expressiveness but also potential for human error. 

      > e.g.
      >
      > `$ ls -l /path/to/my/file`
      >
      > `-rw-r--r-- 1 fred staff 14507 May 1 2019 /path/to/my/file`
      >
      > This is complex. File has `rwx-`style permissions, but also has
      >
      > - Directory traversal rules
      > - Per-filesystem options
      > - On modern Unix, also a near-arbitrary access control list

- Layers of defence (a.k.a. the Swiss cheese model)
  - Security is NEVER absolute, since
    - It is relative to attack model and attacker budget. 
    - Methods are often complex, means can be incorrrectly performed. 
  - Effective computer security relies on *layers of defence*. 
    
  - Each layer of defence is a distinct pratice or technique, and often at different layers in the system. 
  
    > e.g.
    >
    > - Defensive programming
    > - Static analysis
    > - Use of languages with dynamic safety properties
    > - Strong user-system and system-user authentication
    > - Authentication of installed software
    > - Tight access control policy, including least-priviledge operation. 
    > - Network security, e.g., firewalling. 
    > - Audit trail (logging)
    > - User training
    > - Staff training
    > - ...

##### 24.3. Supporting Least Privilege in the OS

- Privilege Escalation

  - When run a program on the system like this `stephen@ernest-7$ ./myprog`, Usually it gets <u>all of the privileges</u>. 

    - It is convenient, and fine if the program is correct and trustwhothy.
    - But this bring a potential security risk. Since web servers are big and complex, unlikely all the programs are correct and trustworthy. 

  - Complex software can often be tricked or exploited, so might do unitended things. This is called **privilege escalation**. 

    > e.g.
    >
    > For system processes, 
    >
    > `root@ernest-7$ ./httpd  # run a web server`
    >
    > It is not wise to give all the privileges. 
    >
    > Note that on a Unix system, `root` is the superuser (a.k.a. administrator) and has permission to do everything. 

- Least Privilege

  - Web servers don't need permission to do everything. 

    > e.g.
    >
    > For system processes, 
    >
    > `root@ernest-7$ ./httpd  # run a web server`
    >
    > We may want to make a new user that is just the web server instead of using `root`. 
    >
    > `root@ernest-7:$ sudo -u httpd ./httpd # run as the user 'httpd'`
    >
    > Then revise our access control policy to say waht the 'web server user' can do, i.e., lessen its privileges to be (a better approximation of) only the least privilege it needs. Then even if it is vulnerable to exploit, the worst it can do is the things the user can do, instead of anything. 


##### 24.4. Splitting up privilege

- It's hard work to divide up privileges really fine, since it needs

  - Create all those distinct users with corresponding set of privileges. Wrong setting will let the programs fail. 
  - Some programs need to combine multiple authorities

    > e.g. `student@5CCS2OSC:$ submit 1 ~/my-proj-1`
    >
    > This program needs
    > - Permission of students - on the project files
    > - Permission of the lecturer - on submission dir, making info, ...

    > The Unix 80% solution is `setuid` and `segtid` programs. 

- Special permission bits in Unix: *set user ID* and *set group ID*

  - Permission bits

    > e.g.
    >
    > `$ ls -l /shared/5CCS2OSC/submit`
    > `-rwsrws--x l k2144518 k2144518 1102992 Mar 9 12:19 /shared/5CCS2OSC/submit`
    >
    > first `s` - when run (by anyone), uid is owning uid
    >
    > second `s` - when run (by anyone), gid is owning gid
    >
    > final `x` - anyone can run

  - System calls methods
    - A program's owner can make it `setuid` meaning "run with any privileges, not the invoking user's"
    - The `seteuid()` system call allows programs to drop the owner's privileges and switch to the invoking user's. 
    - `setgid` is the same idea but apply to the *group ID*. 
  - This allows flexible combinations of invoker's and owner's authorities. 
    - Notice that, "Flexible" means *complex and liable to be got wrong*. 
    - `submit` is simple enough to be auditable, but not all setuid programs are so simple. 

- Setuid Programs

  > e.g.
  >
  > `stephen@ernest-7$ ls /usr/bin/pkexec`
  > `-rwsr-xr-x 1 root root 27468 Jan 18 2022 /usr/bin/pkexec`
  
  - Approach
  
    - A setuid program owned by root is called **setuid root**. It is *dangerous*, since it will run as the all-powerful root user.
    - A setuid program is usually controlled by a configuration file to <u>allow a few carefully chosen privileged things</u> that the system doesn't otherwise let ordinary users do. 
  
  
    > e.g.
    >
    > Launch a program as another, restricted user (like `httpd`). 
    >
    > Launch a program that directly accesses a specific device. 
  - Safety
  
    - A program like the example may face some problems. 
  
    - Privilege escalation
  
      > i.e.
      >
      > Badly-written setuid code allows any user to get root, if they run the code the ‘right way’.
      >
      > The exploit is non-trivial: requires working with several incidental ‘found’ components of the program, and working around some defensive programming by stringing together multiple tricks.
      >
      > The key vulnerability it exploits is a buffer overflow.
  
    - Confused deputy, a special case of privilege escalation
  
      > i.e.
      >
      > Confused deputies happen when buggy code is acting under two or more authorities...

##### 24.5. Preventing Attacks

- Systems without using setuid root
- Fine-grained and explicit use of authority
  - Only use the root privilege for the operation that needs it, i.e., for running the requested child program. 
- Bounds checking, a.k.a. memory-safe execution
  - Check the bounds to prevent buffer overflow attack. *e.g., Implementation in Java.* 
- 





---

### 25. 









---

### 25. Authentication





---

### 26. Cryptography
