## WEEK IX - Logical Programming II

>[🏠 MENU - 5CCS2PLD](year2/5ccs2pld.md)
>
>[⬅️ WEEK VIII - Logical Programming I](year2/5ccs2pld/w8.md)
>
>[➡️ WEEK X - Revision II](year2/5ccs2pld/w10.md)
>
>Outlines:
>
>

### 22. Unification

- Introduction

  - **Unification** is the process of the following, 
    - Intuition for logic programming
      - Use *formulae* to express knowledge and describe problems.
      - Use *inference* to compute with knowledge and solve problems. 
    - Experimenting with the language
      - Theory - unification and SLD-resolution
      - Pratice - implementation in Prolog
  - Histroy of unification

- Uniication

  - A **unification problem** $\mathcal{U}$​ is <u>a set of questions</u> between terms containing variables, denoted as

  $$
  \{s_1 = t_1, ..., s_n = t_n\}
  $$

  - A solution to $\mathcal{U}$, also called a **unifier**, is a substitution $\sigma$, such that when applied to every term in $\mathcal{U}$, for each equation $s_i=t_i$, the terms $s_{j\sigma}, t_{j\sigma}$ are syntatically identical. 

  - The *most general unifier (mgu)* is a unifier $\sigma$ such that any other unifier $\rho$ is an instance of $\sigma$​. 

    > e.g.
    >
    > Consider the following unification problem $\mathcal{U}=\{f(X) = f(Y)\}$ and the substitutions $\sigma = \{X \mapsto Y\}$ and $\rho = \{X \mapsto a; Y \mapsto a\}$. 
    >
    > > - Both substitutions make the terms $f(X)$ and $f(Y)$​​ syntactically identical, i.e.,
    > >
    > >   $f(X)\sigma = f(Y) = f(Y)\sigma$​
    > >
    > >   $f(X)\rho = f(a) = f(Y)\rho$​
    > >
    > >   Hence they are both unifiers. However, 
    > >
    > >   - $\sigma$ is more general than $\rho$ because $\rho$ is an instance of $\sigma$ (by applying the substitution $\gamma = \{Y \mapsto a\}$ after $\sigma$ gives us $\rho$). 
    > >   - But $\rho$ is not an instance of $\sigma$ sicne we cannot get $\sigma$ from $\rho$. 
    > >
    > > - In fact, in this case we can say that $\sigma$ is the most general unifier because no other unifier is more general than $\sigma$ is. 

- Intitution

  - Mechanism on substitutions

    - Substitutions are applied to entire clauses to allow them to resolve. 

    - Substitutions that commit variables to specific terms (e.g., constants and function terms) to <u>prevent future substitutions being able to act as unifiers</u>. 

      > e.g.
      >
      > We can unify the atoms $p(X), p(Y)$ in the clauses $p(X) \vee \neg q(X)$ and $\neg p(Y)$, either by 
      >
      > 1. replacing $X \mapsto Y$ (or $Y \mapsto X$), or 
      > 2. replacing both of $X, Y$ by a constant $a$​. 
      >
      > Whereas the first two substitutions would allows us to then unify the resolvent $\neg q(X)$ (or $\neg q(Y)$) with the clause $q(b)$​, the former would not. 
      >
      > i.e., Replacing method 2. (replace variables to a constant) will generate a new clause $\neg q(a)$ and would not allow the resolution of this clause with any atom involving anything other than $a$. 

  - We want to leave the variables *free*, unless we need to bind them for the unification to succeed. 

- Unification Algorithm

  - Definition

    - The unification algorithm will
      - find the *mgu* for a unification problem if a solution exists, 
      - or otherwise fails, indicating that there are no solutions. 
    - To find the *mgu*, the algorithm <u>simplifies the set of equations using a set of transformation rules</u>. 
      - At each step, either a new set of equations is produced or a failure case arises.
      - The algorithm terminates and outputs the *mgu* when no rule may be applied. 

  - Algorithm rules

    - *Input:* a finite set of equations, $\{s_1 = t_1, ..., s_n = t_n\}$. 

    - *Output*: the *mgu* of those equations, or failure. 

    - Rules
      $$
      \begin{matrix}
      
      1. &f(s_1,..., s_n) = f(t_1, ... t_n), E &\to &s_1 = t_1, ..., s_n = t_n, E \\
      2. &f(s_1,...,s_n) = g(t_1,...,t_m), E &\to &\text{failure} \\
      3. &X = X, E &\to &E \\
      4. &t = X, E &\to &X = t, E &\text{ if } t \text{ is not a variable} \\
      5. &X = t, E &\to &X = t, E\{X \mapsto t\} &\text{ if } X \text{ not in } t \text{ and } X \text { in } E \\
      6. &X = t, E &\to &\text{failure} &\text{ if } X \text{ occurs in } t \text{ and } X \neq t \\
      
      \end{matrix}
      $$

      - Notice that
        - The cases 1. and 2. apply also to constants (arity 0), i.e., In the first case the equation is eliminated and in the second failure arises. 
        - The test in case 6. is called an **occur-check**. e.g., If $X = f(X)$ is a failure case, this test is time consuming, and for this reason in some systems it is not implemented. 

  - Features

    - The unification algorithm applies the rules in a non-deterministic way until no rule can be applied or a failure case arises. 
    - In the case of success, by changing each $=$ in the final set of equation to $\mapsto$ we obtain the *mgu* of the initial set of terms. 
    - The <u>order of equations in the problem is NOT important</u> because we are working on *sets* of equations. 

  - Examples

    > e.g.
    >
    > *Input*: $\{f(a, a) = f(X, a)\}$​
    >
    > - Using rule 1. with the first equation
    >
    >   $\{a = X, a = a\}$
    >
    > - Using rule 4. with the first equation
    >
    >   $\{X = a, a = a\}$
    >
    > - Using rule 1. with the second equation
    >
    >   $\{X = a\}$
    >
    > *Output*: $\{X \mapsto a\}$

    > e.g.
    >
    > *Input*: $\{[X | L] = [0], Y = [1, 2], [X | Z] = U\}$​
    >
    > - Using rule 1. with the first equation
    >
    >   $\{X = 0, L = [], Y = [1, 2], [X | Z] = U\}$
    >
    > - Using rule 5. with the first equation
    >
    >   $\{X = 0, L = [], Y = [1, 2], [0 | Z] = U\}$
    >
    > - Using rule 4. with the last equation
    >
    >   $\{X = 0, L = [], Y = [1, 2], U = [0 | Z]\}$
    >
    > Output: $\{X \mapsto 0, L \mapsto [], Y \mapsto [1, 2], U \mapsto [0 | Z]\}$

---

### 23. SLD-Resolution and Back-tracking





---

### 24. Loops and Constructing SLD-Resolution Trees

