## WEEK IV - Induction & Structural Operational Semantics

>[üè† MENU - 5CCS2PLD](year2/5ccs2pld.md)
>
>[‚¨ÖÔ∏è WEEK III - SIMP & Abstract Machine](year2/5ccs2pld/w3.md)
>
>[‚û°Ô∏è WEEK V - Revision I](year2/5ccs2pld/w5.md)
>
>Outlines:
>
>- Induction
>- Small-Step Operational Semantics
>- Big-Step Operational Semantics

### 9. Recap for Induction

##### 9.1. The Principle of Mathematical Induction

- Induction

  - For any property $P(n)$ of natural numbers *(i.e. $n ‚àà \mathbb{N} = \{0,1,2,...\}$)*, to prove $‚àÄn ‚àà \mathbb{N}.P(n)$‚Äã it is sufficient to show that

    - Base Case: $P(0)$
    - Induction Step: $‚àÄn ‚àà \mathbb{N} .P(n) \implies P(n + 1)$‚Äã‚Äã


  > e.g.
  >
  > We prove that for all natural numbers $n$ that $\Sigma^n_{i=1}(2i-1)=n^2$
  >
  > - Base: $0=0^2$
  >
  > - Induction: 
  >
  >   Assume $\Sigma^n_{i=1}(2i-1)=n^2$‚Äã‚Äã
  > 
  >   $\Sigma^{n+1}_{i=1}(2i-1)=\Sigma^n_{i=1}(2i-1)+2(n+1)-1=n^2+2n+1=(n+1)^2$

##### 9.2. Structural Induction

- Principle

  - We denote an empty list by $\text{nil}$, and a non-empty list by $\text{cons}(h,l)$ where $h$ is the head element and $l$ is the tail of the list.
  - To prove that a property $P$ holds for every list, it is sufficient to prove that
    - Base Case: $P(\text{nil})$
    - Induction Step: $P(l) \implies P(\text{cons}(h,l)) \text{ for all }h, l$‚Äã  

  - More generally, if we are working with finite labelled trees and we want to prove a property $P$ for those trees, it is sufficient to show that
    - Base Case: $P(l)$ for all leaf nodes $l$
    - Induction Step: for each tree constructor $c (\text{with } n ‚â• 1 \text{ arguments}): ‚àÄt_1, . . . , tn.P(t_1) ‚àß ... ‚àß P(t_n) ‚áí P(c(t_1, ... , t_n))$‚Äã


  >e.g.
  >
  >To prove that a property $P$‚Äã holds for all integer expressions in SIMP
  >
  >- Base: 
  >  - Prove $P(n) \text{ for all } n‚àà\mathbb{Z}$‚Äã
  >  - Prove $P(!l) \text{ for all locations }l$
  >- Induction: 
  >  - For all integer expressions $E, E'$ and operators $op$, Prove that $P(E), P(E') \implies P(E\ op\ E')$

  - Remark

    - The principle of structural induction can be justified by the principle of mathematical induction. 
    - This is because we work with *finite* trees, so we can understand structural induction as induction on the *size* of the tree.

- Application of the Structural Induction Principle

  - Property
    - The semantics of SIMP guarantees that for any integer expression $E$ appearing in a program working on a memory $m$, if $E$ uses locations that are defined in $m$ then the value of $E$‚Äã is defined.
    - i.e., For any configuration $‚ü®E ¬∑ c , r , m‚ü©$ where $c$ is any arbitrary control stack and $r$ is also arbitrary, there is a configuration $‚ü®c,n¬∑r,m‚ü©$ such that $‚ü®E¬∑c,r,m‚ü© \rightarrow^‚àó ‚ü®c,n¬∑r,m‚ü©$‚Äã‚Äã.
    
    > *Proof.* 
    >
    > 1. Natural Numbers: 
    >
    >    - Axiom: 0
    >    - Rule: $(\{n\}, n + 1)$, This is usually written in $\frac{n}{n+1}$‚Äã
    >
    > 2. Evaluation relation for integer expressions in SIMP: 
    >
    >    - Notation: $(E,m) ‚áì$ (where $n$ means that $E$ evaluates to $n$ in the state $m$)
    >
    >    - Axioms:
    >
    >      $(n, m) ‚áì n$	for all integer numbers $n$
    >
    >      $(!l,m) ‚áì n$	if $l \in \text{dom}(m) \text{ and } m(l)=n$
    >
    >    - Rule:
    >
    >      $\frac{(E_1,m) ‚áì n1\ \ (E_2,m) ‚áì n_1}{(E_1\ op\ E_2, m)‚áì n}$	if $n=n_1\ op\ n_2$‚Äã


##### 9.3. Rule Induction

- Principle

  - Let $I$ be a set defined by induction with axioms and rules $(A,R)$. To show that $P(i)$ holds for all $i \in I$, it is sufficient to prove
    - Base Case: $‚àÄa \in A.P(a)$
    - Induction Step: $‚àÄ({h_1, ... h_n}, c) \in R. P(h_1) ‚àß ... ‚àß P(h_n) \implies P(c)$‚Äã

  > e.g.
  >
  > Each integer expression in SIMP has a unique value under the evaluation relation $‚áì$.
  >
  > - Base Case: Trivial, since numbers have unique values.
  > - Induction Step: For non-atomic expressions, we remark that the value of an arithmetic expression is uniquely determined by the values of its arguments, which are unique by the induction hypotheses.

- Special Principle

  - In some cases we are only interested in proving a property for a subset $J$‚Äã of the inductive set I defined by $(A,R)$. Then we can use a special case of the principle of rule induction, which says that to prove that a property $Q(x)$ holds for all the elements of $J$, it is sufficient to show:
    - Base Case: $‚àÄa \in (A ‚à© J).Q(a)$
    - Induction Step: $‚àÄ (H, c) \in R \text{ such that } c \in J, (‚àÄh ‚àà H ‚à© J.Q(h)) \implies Q(c)$‚Äã‚Äã

---

### 10. Small-Step Operational Semantics for SIMP

>Summary:
>
>- A transition system for SIMP, where the transition relation is defined by induction.
>  - Transition steps represent steps of computation
>  - The result of the program $P$ in a memory state $s$ can be found by performing transition steps starting from $‚ü®P,s‚ü©$ until a *terminal configuration* is obtained (not all configurations reach a terminal configuration).

##### 10.1. Conponents

- Configurations

  - We define a transition system with **configurations** $‚ü®P,s‚ü©$
    - $P$ is a SIMP program, and
    -  $s$ is a store (memory) represented by a partial function from locations to integers

  > Notation:
  >
  > $s[l \mapsto n]$ denotes  the function $s'$ that coincides with $s$ except that it associates to $l$ the value $n$‚Äã. More precisely, 
  >
  > $s[l \mapsto n](l) = n$
  > $s[l \mapsto n](l') = s(l') \text{ if } l \neq l'$

- Transition Relation

  - The **transition relation $\rightarrow$ on configurations** is inductively defined by the axioms and rules (below).
    - The expression $E$ has the value $n$ in the memory state $s$ if $‚ü®E,s‚ü© \rightarrow^‚àó ‚ü®n,s'‚ü©$‚Äã.
    - The command $C$ has a <u>successful execution</u> in the memory state $s$ if $‚ü®C,s‚ü© \rightarrow^‚àó ‚ü®\text{skip},s'‚ü©$. We say that $C$ in s produces $s'$.

##### 10.2. Expression and Commands

- Semantics for expressions
  $$
  \begin{matrix}
  \frac{\ }{‚ü®!l,s‚ü© \rightarrow ‚ü®n,s‚ü©, \text{ if }s(l)=n} &\text{(var)} \\
  \frac{\ }{‚ü®n_1\ op\ n_2,s‚ü© \rightarrow ‚ü®n, s‚ü©, \text{ if } n=(n_1\ op\ n_2)} &\text{(op)} \\
  \frac{\ }{‚ü®n_1\ bop\ n_2,s‚ü© \rightarrow ‚ü®n, s‚ü©, \text{ if } n=(n_1\ bop\ n_2)} &\text{(bop)} \\
  \frac{‚ü®E_1, s‚ü© \rightarrow ‚ü®E_1', s'‚ü©}{E_1\ op\ E_2, s‚ü© \rightarrow ‚ü®E_1'\ op\ E_2, s'‚ü©} &(\text{op}_L) \\
  \frac{‚ü®E_2, s‚ü© \rightarrow ‚ü®E_2', s'‚ü©}{E_1\ op\ E_2, s‚ü© \rightarrow ‚ü®E_1\ op\ E_2', s'‚ü©} &(\text{op}_R) \\
  \frac{‚ü®E_1, s‚ü© ‚Üí ‚ü®E_1', s'‚ü©}{E_1\ bop\ E_2, s‚ü© \rightarrow ‚ü®E_1'\ bop\ E_2, s'‚ü©} &(\text{bop}_L) \\
  \frac{‚ü®E_2, s‚ü© \rightarrow ‚ü®E_2', s'‚ü©}{E_1\ bop\ E_2, s‚ü© \rightarrow ‚ü®E_1\ bop\ E_2', s'‚ü©} &(\text{bop}_R) \\
  \frac{\ }{‚ü®b_1 ‚àß b_2, s‚ü© ‚Üí ‚ü®b, s‚ü©, \text{ if } b = (b_1 \text{ and } b_2)} &\text{(and)} \\
  \frac{\ }{‚ü®\neg b,s‚ü© \rightarrow ‚ü®b',s‚ü©, \text{ if } b' = \neg b} &\text{(not)} \\
  \frac{‚ü®B_1,s‚ü© \rightarrow ‚ü®B_1',s'‚ü©}{‚ü®\neg B_1,s‚ü© \rightarrow ‚ü®\neg B_1,s ‚ü©} &\text{(notArg)} \\
  \frac{‚ü®B_1,s‚ü© \rightarrow ‚ü®B_1',s'‚ü©}{‚ü®B_1 ‚àßB_2,s‚ü© \rightarrow ‚ü®B_1' ‚àßB_2,s ‚ü©} &(\text{and}_L) \\
  \frac{‚ü®B_2,s‚ü© \rightarrow ‚ü®B_2',s'‚ü©}{‚ü®B_1 ‚àßB_2,s‚ü© \rightarrow ‚ü®B_1 ‚àßB_2',s ‚ü©} &(\text{and}_R) \\
  
  \end{matrix}
  $$

  >e.g.
  >
  >Let $s$ be a state such that $s(z) = 0$ and let $E =!z + 1$. The expression $E$ evaluates to $1$ in $s$, since $‚ü®!z + 1, s‚ü© \rightarrow ‚ü®0 + 1, s‚ü© \rightarrow ‚ü®1, s‚ü©$
  >
  >This is shown as follows
  >
  >1. $\frac{\frac{\ }{‚ü®!z,s‚ü© \rightarrow ‚ü®0,s‚ü©} \text{(var)}}{‚ü®!z+1, s‚ü© \rightarrow ‚ü®0+1, s‚ü©} (\text{op}_L)$ 
  >2. $\frac{\ }{‚ü®0+1,s‚ü© \rightarrow ‚ü®1, s‚ü©} \text{(op)}$‚Äã

- Semantics For commands

  - ...

  > e.g.
  >
  > Let $P$ be the program `z:= !x; x:= !y; y:= !z` and $s$ a state such that $s(z) = 0, s(x) = 1, s(y) = 2$‚Äã‚Äã.
  >
  > There is a sequence of transitions:
  >
  > $‚ü®P,s‚ü© \rightarrow ‚ü®z := 1;(x :=!y;y :=!z),s‚ü©$
  >
  > $\rightarrow ‚ü®\text{skip; (x :=!y; y :=!z)}, s[z \mapsto 1]‚ü©$‚Äã
  >
  > $\rightarrow ‚ü®\text{x :=!y; y :=!z}, s[z \mapsto 1]‚ü©$‚Äã
  >
  > $\rightarrow ‚ü®\text{x := 2;y :=!z},s[z \mapsto 1]‚ü©$‚Äã
  >
  > $\rightarrow ‚ü®\text{skip;y :=!z},s[z \mapsto 1,x \mapsto 2]‚ü©$‚Äã
  >
  > $\rightarrow ‚ü®\text{y :=!z},s[z \mapsto 1,x \mapsto 2]‚ü©$‚Äã
  >
  > $\rightarrow ‚ü®\text{y := 1},s[z \mapsto 1,x \mapsto 2]‚ü©$‚Äã
  >
  > $\rightarrow ‚ü®\text{skip},s[z \mapsto 1,x \mapsto 2,y \mapsto 1]‚ü© $

- Remark

  - There is no axiom or rule for programs of the form of the following
    - $‚ü®n, s‚ü©$ where $n$‚Äã is an integer
    - $‚ü®b, s‚ü©$ where $b$‚Äã is a boolean
    -  $‚ü®!l, s‚ü©$ where $l \notin \text{dom}(s)$
    - $‚ü®\text{skip}, s‚ü©$
  - These are *terminal configurations*. In the case of $‚ü®!l,s‚ü©$ where $l \notin \text{dom}(s)$‚Äã we say that **the program is blocked**.

##### 10.3. Comparison with the Abstract Machine

|              | Small-Step Operational Semantics                             | Abstract Machine                                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| *Transition* | Each transition is a part of the computation that leads to the result | Some of the transitions of the machine were only manipulating syntax |
| *Validation* | To show that a sequence of reductions is valid we need a proof |                                                              |

>e.g.
>
>$‚ü®\text{if } !l > 0 \text{ then (C';C) else skip},s‚ü© ‚Üí ‚ü®\text{if } 4 > 0 \text{then (C';C) else skip}, s‚ü©$ can be proved if $s(l)=4$

---

### 11. Big-Step Semantics for SIMP

##### 11.1. Recap on Deterministic

- Definition

  - A **determinisitc** system is a system that: 

    - Given a configuration $‚ü®P,s‚ü©$ there is a unique sequence of transitions from $‚ü®P,s‚ü©$ with maximal length. This is called the **evaluation sequence** for $‚ü®P,s‚ü©$‚Äã.
    - The evaluation sequence for $‚ü®P,s‚ü©$‚Äã may be finite or infinite.

  - Evaluation Sequence

    - *Terminating*
      - If the sequence eventually <u>reaches a terminal non-blocked configuration</u>
      - i.e., A configuration of the form $‚ü®n,s‚ü©$ where $n$ is an integer, or $‚ü®b,s‚ü©$ where b is a boolean, or $‚ü®\text{skip},s‚ü©$.
    - *Blocked (Stuck)*
      - If the sequence eventually <u>reaches a blocked configuration</u> 
      - i.e., A configuration of the form $‚ü®!l,s‚ü©$ where $l \notin \text{dom}(s)$).
    - *Divergent*
      - If the sequence is <u>infinite</u>.

    > e.g.
    >
    > - $‚ü®\text{while True do skip},s‚ü©$ is divergent.
    > - $‚ü®\text{if !x = 0 then skip else skip},s‚ü©$ is stuck if $\text{dom}(s)$ does not contain $x$.
    > - $‚ü®\text{if 4 = 0 then skip else skip},s‚ü©$ is terminating.

##### 11.2. Big-Step Semantics

- Definition

  - The goal is to define a binary relation between configurations, which associates a configuration with its corresponding terminal one (if it exists).
  - That is, define by induction the binary relatio $‚ü®P, s‚ü© \rightarrow^‚àó ‚ü®P', s'‚ü©$ such that $‚ü®P', s'‚ü©$‚Äã is *terminal*.

  > Notation:
  >
  > The usual notation for this is $‚ü®P, s‚ü© ‚áì ‚ü®P', s'‚ü©$ 
  >
  > i.e., $‚ü®P,s‚ü© ‚áì ‚ü®P',s'‚ü©$ if $‚ü®P,s‚ü© \rightarrow^‚àó ‚ü®P',s'‚ü©$ where $‚ü®P', s'‚ü©$‚Äã is terminal.

- Expressions

  - ...

- Commands

  - ...

  > e.g.
  >
  > Consider the program $P$ : `(z :=!x;x :=!y);y :=!z` and a state $s$ such that $s(z)=0,s(x)=1,s(y)=2$.
  >
  > We can prove that $P ‚áì ‚ü®\text{skip},s‚Ä≤‚ü©$ where $s'(z) = 1, s'(x) = 2, s'(y) = 1$. 

##### 11.3. Variable Declaration

- Local Declaration

  - We can add local declarations to SIMP by using a **local state** 
    - The scope of a newly created location corresponds precisely with the block where the location is created and initialised (static scope).
    - For this we will need a *stack* based implementation of the state.

- Implementation

  - Syntax

    We extend the syntax of SIMP with blocks.
    `C ::= begin loc x := E; C end`

  - Semantics

    We add the following rule to the big-step semantics

    $$
    \frac{‚ü®E,s‚ü© ‚áì ‚ü®n,s'‚ü© ‚ü®C\{x \mapsto l\},s'[l \mapsto n]‚ü© ‚áì ‚ü®\text{skip},s''[l \mapsto n']‚ü©}{‚ü®\text{begin loc x := E;C end},s‚ü© ‚áì ‚ü®\text{skip},s''‚ü©}
    $$
    where
    
    - $l \notin \text{dom}(s') ‚à™ \text{dom}(s'') ‚à™ \text{locations}(C)$, that is, $l$ is a fresh name
    - $C\{x \mapsto l\}$ is the program $C$ where all the occurrences of $x$ are replaced by $l$ (to avoid confusion with other variables of the same name in other parts of the program).
  
  > e.g.
  >
  > The following program $P$ swaps the contents of $x$ and $y$ using a local variable $z$:
  >
  > ```
  > begin
  > 	loc z :=!x; x :=!y;
  > 	y :=!z
  > end
  > ```
  >
  > To show that the program $P$ is correct,
  >
  > 1. First we prove
  >
  >    $‚ü®\text{x :=!y;y :=!l},s[l \mapsto s(x)]‚ü©‚áì‚ü®\text{skip},s[x \mapsto s(y),y \mapsto s(x)]‚ü©$
  >
  > 2. Let us call $s'$ the store $s[x \mapsto s(y),y \mapsto s(x)]$‚Äã, then,
  >
  >    $\frac{\frac{\ }{‚ü®!x,s‚ü© ‚áì ‚ü®s(x),s‚ü©} ‚ü®\text{x := !y ; y := !l},s[l \mapsto s(x)]‚ü© ‚áì ‚ü®\text{skip},s'‚ü©}{‚ü®P, s‚ü© ‚áì ‚ü®\text{skip}, s'‚ü©}$
  
  
  
  