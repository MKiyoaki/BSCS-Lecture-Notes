## WEEK III - Java synchronization

>[🏠 MENU - 5CCS2OSC](year2/5ccs2osc.md)
>
>[⬅️ WEEK II - Multithreading in Java](year2/5ccs2osc/w2.md)
>
>[➡️ WEEK IV - ](year2/5ccs2osc/w4.md)
>
>Outlines:

### 6. 

##### 6.1. Recall for Multithreading

- Problem for data sharing between threads

  > If two threads accessing a single variable (a counter) can leave the counter in an indeterminate state because the operation used on the counter is not atomic (the ++ operator). 
  >
  > That particular operator consists of three separate operations.

- Solution

  - Java provides a number of approaches that enable the programmer to avoid such problems. 
  - The solutions usually involve preventing multiple threads accessing a shared object concurrently.

> e.g.
>
> ```java
> public class MemoryDemoRunnable3 implements Runnable {
>        private int counter = 0;
>        public void run() {
>           for (int i = 0; i < 100_000; i++) {
>              incCounter();
>           }
>           System.out.println(
>             Thread.currentThread().getName() 
>             + " " + counter
>           );
>        }
>        private void incCounter() {
>          counter++; 
>        }
>        public static void main(String[] args) {
>           MemoryDemoRunnable3 runnable1 = new
>               MemoryDemoRunnable3();
>           Thread thread1 = new Thread(runnable1);
>           Thread thread2 = new Thread(runnable1);
>           thread1.start();
>           thread2.start();
>        }
> }
> ```

##### 6.2. Java synchronized

- Critical section - Issue

  - A **critical section** is a sequence of instructions that <u>only one thread at a time should be allowed to execute, otherwise we get incorrect or unpredictable behaviour</u>.
  - We protect critical sections with the notion of **mutual exclusion**, which simply means that one thread at a time gets exclusive access to a critical section.
  - In general we protect such sections with **locks**.

- Java synchronized

  >e.g.
  >
  >```java
  >public class SynchronizedMethodDemo2 implements Runnable {
  >        private int counter = 0;
  >        public void run() {
  >          for (int i = 0; i < 100_000; i++) {
  >             incCounter();
  >          }
  >          System.out.println(
  >            "Final Counter: "+
  >            Thread.currentThread().getName() + " " +
  >            counter
  >          );
  >        }
  >        private synchronized void incCounter() {
  >          counter++; 
  >        }
  >        public static void main(String[] args) {
  >          SynchronizedMethodDemo2 runnable1 = new
  >              SynchronizedMethodDemo2();
  >          Thread thread1 = new Thread(runnable1);
  >          Thread thread2 = new Thread(runnable1);
  >          thread1.start();
  >          thread2.start();
  >        }
  >}
  >```

  - Declare a method `synchronized`
    - the JVM will ensure that only one thread at a time can enter that method hence this defines a critical section that consists of the entire method.
    - This will ensure that a thread can’t be interrupted by another thread while it manipulates the counter. 
    - In this case, since `counter++` is the only instruction in the method, it makes that instruction effectively atomic (but only in this method).
  - One of the threads will generally reach the indexing limit in its loop before the counter has reached the final total. 
    - This is because, although we now do not have the threads interrupting each other in the middle of an instruction, they do still interrupt each other in terms of progress towards the final result.
    - We can think of this as the threads *cooperating* to get to the required total, rather than each one attempting to do that.

- Locks

  - Definition

    - A lock is a construct that enables the programmer to declare a critical section that can only be accessed by one thread at a time.

  - Process

    >If *Thread A* holds the lock for a particular critical section, and *Thread B* attempts to acquire the lock, *Thread B* will be blocked until *Thread A* releases the lock. 
    >
    >If *Thread A* never releases the lock, *Thread B* will <u>block</u> forever.

    - Just <u>before entering</u> the critical section the thread attempts to **acquire** the lock. If this is successful then the thread will enter the critical section.
    - When the thread exits the critical section it **releases** the lock.

- Intrinsic Locks

  - Definition
    - Every Java object has a lock associated with it, called its **intrinsic lock**.
  - Process
    - When we define a critical section with synchronized we are defining the critical section with respect to a particular object.
  - Considering the previous example
    - The object that will be protected in its critical section is the object represented by this, *i.e. the current objec*t.
    - We do not have to specify that we are locking on this since that it is implicit, in this case.

  - 

---
