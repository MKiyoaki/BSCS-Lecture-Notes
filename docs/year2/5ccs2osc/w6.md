## WEEK VI - Memory Address Management

>[üè† MENU - 5CCS2OSC](year2/5ccs2osc.md)
>
>[‚¨ÖÔ∏è WEEK V - Introduction to OSss](year2/5ccs2osc/w5.md)
>
>[‚û°Ô∏è WEEK VII - ](year2/5ccs2osc/w7.md)
>
>Outlines:

### 14. The address-binding problem

> Ref:
>
> [Address-binding in OS - javatpoint](https://www.javatpoint.com/address-binding-in-operating-system)

##### 14.1. Introdcution

- Definition
  - Virtual Memory Address
  
  - Physical Memory Address
  
- The address-binding problem is for addressing with the following problems, 
  1. The OS requirment - efficiently, reliable, securely

     - Each process requires the illusion of its own computer, including its own memory. 

     - Be *reliable* and *securely*, i.e., the OS need to prevent one process from accessing another's memory, need to protect the process if the user of another process is malicious

  2. Problem with starting address allocation
     - Multiple processes cannot all start from the address of 0

  3. Problem with memory address reference
     - Machine instructions (program text) may refer some absolute address of the memory, but the run-time memory addresses might be different from the addresses in the instructions

- Summary

  - How can programs be written as, considering the following points
    - if the memory is private to themselves
    - concrete instructions referencing specific memory addresses, but still executed in a share of physical memory
    - efficiently, reliably, securely

##### 14.2. Simple approach to solve

- Non-solutions

  - avoid multiprogramming - Keep only one program in memory

    > e.g., like the earliest (non-multiprogrammed) batch computers.

    - Forgoes much potential efficiency and functionality
    - Context switching all of memory to/from disk is unworkably slow

  - statically assign address ranges to programs

    - Cannot handle multiple instances of the program
    - The memory cost of each program could be different
    - Causes unworkable *fragmentation* - Every program that might run needs space reserved at all times

- Load-time relocation

  - Process
    - Load the programs from the disk to the memory
    - At the same time, rewrite their references to memory
  - Evaluation
    - **Fault isolation** - ‚ùå
      - One incompetent process could trash another's memory, 
      - Or the OS's memory. 
    - **Security** - ‚ùå
      - One malicious process could trash or *read* another‚Äôs memory 
      - Worse: physical address space often also includes *devices*
    - **Rewriting** - ‚ùå
      -  It might be slow to do rewriting
    - **Fragmentation** - ‚ùå
      - Memory can get *fragmented* in two ways:
        - Internally - to a process 
        - Externally - over all memory
      - Reasons
        - If the relocated processes coexisting, the physical address space can be shared among processes, but the processes <u>are different sizes</u>. 
        - **Contiguous** allocation will be a problem.

- Base and limit registers - memory management unit (MMU)

  - MMU

    > It is just a concept, sicne it is integrated into modern CPUs in reality.

    - Each memory access is checked against *base* and *limit* by the hardware
      - Check fails lead to
        - a hardware interrupt
        - OS kills the process (probably)
      - Set *base* and *limit*
        - privileged instructions
        - only work in *kernel mode*
    - A *system call* - will save and reset (restore on return), just like other registers
    - A *context switch* - will save and to be restored later,  just like other registers

  - Evaluation

    - **Fault isolation** - ‚úÖ
    - **Security **- ‚úÖ
    - **Rewriting **- ‚úÖ
    - **Fragmentation **- ‚ùå
      - Still, memory can get *fragmented* in two ways:
        - Internal - if base and limit must stay fixed
        - External - maybe the OS could support growing processes on demand

---

### 15. Segementation and Page Tables

>Ref:
>
>[‰∏ÄÊñáÂ∏¶‰Ω†‰∫ÜËß£ÔºåËôöÊãüÂÜÖÂ≠ò„ÄÅÂÜÖÂ≠òÂàÜÈ°µ„ÄÅÂàÜÊÆµ„ÄÅÊÆµÈ°µÂºèÂÜÖÂ≠òÁÆ°ÁêÜ - Zhihu](https://zhuanlan.zhihu.com/p/451736494?utm_psn=1745669391663087617)

##### 15.1. 

- Definition

  - **Segement** - A *(base, limit)* pair can be called a **segment** of memory

    > Note: *(base, length)* is slightly more usual than *(base, limit)*

  - If an MMU can work with many such pairs, it supports *segmentation*.

  