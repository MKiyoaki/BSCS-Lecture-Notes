## WEEK IX - Access Control

>[ðŸ  MENU - 5CCS2OSC](year2/5ccs2osc.md)
>
>[â¬…ï¸ WEEK XIII - User-Level Memory Allocation](year2/5ccs2osc/w8.md)
>
>[âž¡ï¸ WEEK X - ](year2/5ccs2osc/w10.md)
>
>Outlines:
>
>

### 23. Introduction to Access Control

##### 23.1. System Defines Mechanism

- Introduction to Access Control Policy
  - File Sharing
    - File Sharing allows multiple users or processes to share with the same file, while the OS only need to keep a copy of it. 

    - Access to objects that may be shared is controlled by the OS. 

      > e.g.
      >
      > Alice can read Alice's mail, but Bob cannot. 

  - Motivation
    - Most modern operating systems are multi-user, that it gives processes a "user identity" so to support with file sharing. Abstractly, it is like a label denoting privilege. 
    - In order to prevent unauthorised modification to the files from other users, there is an **access control policy** that resolved with the permission problems of files, including the permission of r*ead, write and execute*, basing on that user identity. 

  - Access Control Policy

    - OSs aim to provide expressive mechanisms that can represent a range of policies. The specific policy is decided by the users of the system. 

      > e.g.
      >
      > Alice might create a file that anyone can read, but only she can write. 
      >
      > Alice might also create a file that both she and Bob can read and read, but others cannot access. 

    - Example design of Unix

      - In Unix, permission checking is done only at `open()`, if we want to `open()` a file by pathname, and then `read()` and `write()` on file handles. 

      - Permission bits

        - Structure

          > e.g.
          >
          > `alice@host $ ls -l ~/mail-rw-------- 1 alice alice 450871 Mar 4 2023 /home/alice/mail`

        - `rw-` - *owner* (`alice` in this example) can read and write but not execute

        - `---` - other members of the *group* `alice` can do nothing

        - `---` - other users can do nothing

          > e.g.
          >
          > `k2144518@5CCS2OSC: $ ls -ld /shared drwxr-xr-x 4 k2144518 nms_informatics_staff 4096 Mr 9 12:19 5CCS2OSC`

      - Properties

        - **Permission bits** are stored in a Unix filesystem data structure called the `inode` (~ one per file). 

          - After `open()`, having the file handle is enough. Checks are not done at `read()` or `write()`. 

          - However, file descriptors may be restricted at the time of `open()`. 

            > e.g.
            >
            > If we did `int fd = open("/home/alice/mail", O_RDONLY); `, then only `read()`, not `write()` will succeed on handle `fd`. 

      - This design means

        - Cost of checking is *amortised*
        - **Delegation** is possible, because it can even transmit `fd` to other proceses. 
        - But **revocation** is hard, since changing permissions doesn't revoke open `fds`. 

##### 23.2. Modelling Polices

- Access Control Matrix

  - We can draw a big table of who has what access to which object. 

    >     e.g.
    >
    >     |         | `/etc/passwd` | `/vmunix` | `/usr/bin/ls` | `/home/alice/project` |
    >     | ------- | ------------- | --------- | ------------- | --------------------- |
    >     | alice   | read          | -         | read, execute | read, write           |
    >     | bob     | read          | -         | read, execute | read, write           |
    >     | charlie | read          | -         | read, execute | -                     |
    >     | dave    | read          | -         | read, execute | -                     |

    - This is an **access control matrix**. 
    - For representing the matrix into data structures on a running system, we can 
      1. Store with each objects <u>in a list of pairs</u> *(who, what permission)*. These are **access control lists (ACLs)**. 
      2. Give each subject with <u>a list of pairs</u> *(which object, what access)*. Each of these paris is a **capability**, like a file descriptor. 

- Access control lists (ACLs)

  - Properties

    - Unix's `user`, `group`, `other` permission bits are a lmitied ACL. 
    - Full explicit ACLs can become <u>large (when added up) and performance-sensitive (if checks are frequent)</u>. 

  - ACL with objects

    - ACLs protect the object, at the object. 

      > e.g., Unix files at `open()` time. Each file has a (short) ACL. 

      - Pros âœ…

        1. Easy to revoke, since just need to take name off the list
        2. Easy to understand audit

      - Cons âŒ

        1. Scale can become a problem if there are many `{users, files, actions}`. 

           > e.g.
           >
           > Unix has many heuristics aimed at sensible ACL by default: current `uid/gid`, `umask`, `setgid` & sticky directories, etc. 

        2. **Authority** is ambiend, based on "who you are". It cannot *delegate fine-grained access* to some code/process. 

           > i.e., ACL is basing on the identification of user, so it can decide which user can access with which object, but cannot decide like the permission of some specific parts of code or processes. 

           > e.g.
           >
           > Not workable when ACLs with <u>distinct permissions for each process</u>. 

      > Problems will be more serious when distribution. 

- Capabilities

  - Properties

    - The descriptor encapsulates *which file* and *what access*. 
    - Specifically, store capabilities are not with each user but with <u>each process</u>, that enabling them to be *fine-grained* and *dynamic*. 

  - Capabilities with subject, active and maybe process

    - A capability is an unforgeable **token of authority** on some object. 

    - It is a pair of *<object reference, access rights>*. Possessing a valid reference is enough. 

      > e.g., File descripotrs. 
      >
      > - Kernel maintains table of valid `fds`
      > - Can delegate
      > - Hard to revoke

    - Capabilities deeply affect *how programs refer to protected objects*. 

      - Can be fine-grained. 
      - Designated, not ambient. 

      > Validation check can be distributed using cryptography. 


##### 23.3. Summary

| ACLs                            | Capabilities                                  |
| ------------------------------- | --------------------------------------------- |
| Stored with objects             | Stored with subjects                          |
| Check permissions on *access*   | Check permission on *issue + validity* on use |
| Easy to revoke                  | Hard to revoke                                |
| Hard to delegate                | Easy to delegate                              |
| Usually coarse-grained          | Easily made fine-grained                      |
| Easy to audit                   | Hard to audit *(e.g., following delegation)*  |
| Easy to retrofit                | Must usally "design in"                       |
| Tend to bottleneek distrubution | Distributes more scalably                     |
| Authority is ambient            | Authority is designated                       |

---

### 24. Definitions





---

### 25. Authentication





---

### 26. Cryptography
