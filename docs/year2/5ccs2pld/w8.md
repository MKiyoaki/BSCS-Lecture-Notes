## WEEK VIII - Logical Programming I

>[üè† MENU - 5CCS2PLD](year2/5ccs2pld.md)
>
>[‚¨ÖÔ∏è WEEK VII - Functional Programming Types and Semantics](year2/5ccs2pld/w7.md)
>
>[‚û°Ô∏è WEEK IX - Logical Programming II](year2/5ccs2pld/w8.md)
>
>Outlines:
>
>Introduction to Logical Programming
>
>> Basic Concepts
>>
>> Prolog
>>
>> Syntax Basics
>
>

### 19. Introduction to Logical Programming

##### 19.1. Basic Concepts of Logic Programming

- Definition

  - The main idea behind *Logic Programming* is to combine logic and proramming: 

    - Logic is used to express knowledge, describe the program, etc. 
    - Inference is used to compute, manipulate knowledge, and obtain a solution to the problem. 

  - Evaluation

    - Pros ‚úÖ

      - Knowledge-based programming. 
      - It is a *declarative* style of programming. i.e., The program says <u>what should be computed</u> rather than how it is computed. 
      - Precise and simple semantics. 
      - The same formalism can be used to specify a problem, write a program, prove properties of the program. 
      - The same program can be used in many different ways.

      > Note. The previous properties are shared with functional programming while the last property is only for logic programming. 

      > e.g.
      >
      > Consider the following Prolog program to reverse a list of elements, and the three queries A), B) and C) to the program.
      >
      > ```Prolog
      > reverse([], []). 
      > reverse([H|T], List) :- reverse(T, Z), append(Z, [H], List). 
      > 
      > # A)
      > ? - reverse([1, 2, 3], X). 
      > X = [3, 2, 1].
      > 
      > # B)
      > ? - reverse(X, [3, 2, 1]). 
      > X = [1, 2, 3]. 
      > 
      > # C)
      > ? - reverse([1, 2, 4], [3, 2, 1]). 
      > false. 
      > 
      > ```
      >
      > Notice that the variable `X` was used in different argument positions in `A)` and `B)` and that no variables were used in `C)`. 
      >
      > This is because unlike in a functional programming language, there is no intrinsic notion of "input" and "output" variables. 

    - Cons ‚ùå

      - Ability to support efficient arithmetic and input/output operations such as file handling, are provided at the expense of declarative semantics. 
      - Most logic languages are restricted to a fragment of classical <u>first-order logic</u>. There are some languages based on more powerful logics, but they are not widely used. 

##### 20.1. Introduction to Prolog

- Definition
  - A famous Functional Programming language - Prolog
  - Introduction
    - SWI Prolog
      - At startup a message will appear, followed by the goal prompt `?-`
      - To load a program from a local file, type `?- ['myprogram.pl'].`
  

##### 19.3. Syntax Basics

- Language Definition

  - Domain of computation - **terms**. 

    - The set of terms is defining using, 

      - *variables*, represented by $X, Y, Z, ...$
      - and *function symbols*, with fixed arities represented by $f, g, h, ...$ or $a, b, c, ...$ for constants or arity zero. 

    - A term is either a variable, or has the form $f(t_1, ..., t_n)$, where $f$ is a function symbolof arity $n$ and $t_1, ..., t_n$ are terms. 

      > e.g.
      >
      > If $a$ is a constant, $f$ is a binary function, and $g$ is a unary function, and $X, Y$ are variables, then the following are possible terms:
      >
      > > $X$‚Äã
      > >
      > > $a$
      > >
      > > $g(a)$
      > >
      > > $f(X, g(a))$
      > >
      > > $Y$
      > >
      > > $f(f(X, g(a)), Y)$‚Äã
      > >
      > > $g(f(f(X, g(a)), Y))$

  - Predicate symbols, atomic formulas and literals

    - Let $p, q, r, ...$‚Äã represent predicate symbols, each with a fixed arity.
    - If $p$ is a predicate of arity $n$ and $t_1, ..., t_n$ are terms, then $p(t_1, ..., t_n)$ is an atomic formula, $A, B, ...$
    - A **literal** is an atomic formula $A$, or a negated atomic formula $\neg A$. 

    > Note. 
    >
    > You can think of a predicate symbol as expressing a relationship between elements of the domain. e.g., Use the predicate `father_of(peter, paul)` to express the fact that Peter is Paul's father. 

    > e.g.
    >
    > If `rainy` and `snowy` are unary predicates, `temperature` is a binary predicate, `celsius` is a unary function symbol, `tuesday` and `zero` are constants. Then the following are possible literals: 
    >
    > >`temperature(tuesday, celsius(zero))`
    > >
    > >`¬¨rainy(tuesday)`
    > >
    > >`snowy(X)`
    >
    > Notice that 
    >
    > 1. Only terms can be used as arguments in predicates. 
    > 2. `celsius(zero)` is a (unary) function term. 

    > e.g.
    >
    > If `a` is a constant, `f` a binary function, and `g` a unary function, and `X`, `Y` are variables, which of these are valid terms; if not, why not?
    >
    > >`(X, a)` ‚ùå
    > >
    > >`g(X)` ‚úÖ
    > >
    > >`g(f)` ‚ùå
    > >
    > >`f(X, f(X, g(f(Y, a))))` ‚úÖ

    > e.g.
    >
    > If `p` is a binary predicate, and `q` a unary predicate, which of these are valid literals; if not, why not?
    >
    > >` ¬¨p(X, a)` ‚úÖ
    > >
    > >`q(g(Y), a)` ‚ùå
    > >
    > >`¬¨p(q(g(Y), g(a)))` ‚ùå Since only terms can be used as arguments to predicates but `q` is a predicate.  

---

### 20. Clauses and Substitutions

##### 20.1. 



##### 20.2. 
