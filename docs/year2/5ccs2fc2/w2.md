## WEEK II - P vs NP

> [🏠 MENU - 5CCS2FC2](year2/5ccs2fc2.md)
>
> [⬅️ WEEK I - Automata and Turing Machines](year2/5ccs2fc2/w1.md)
>
> [➡️ WEEK III - The Cook-Levin Theorem / Divide-and-Conquer](year2/5ccs2fc2/w3.md)
>
> Outlines:
>
> - P vs NP Problem - Definition
>   - P - can be quickly solved
>   - NP - can be quickly verified
> - Computable, NP-hard, NP-completeness
> - The Clique Problem
> - The Hamiltonian Problem

#### 5. P vs NP Problem

> ref: 
>
> [What is P\NP\NPC Problem - Matrix67](http://www.matrix67.com/blog/archives/105)

***Theorm 5.1*** Recap for Asymptotic Notation

- Big Oh Notation (upper bounds)

  - A function $g:\mathbb{N} \to \mathbb{N}$ **eventually dominates** a function $f:\mathbb{N} \to \mathbb{N}$ if there is some constant $c>0$ such that

    $\exists N \in \mathbb{N}\ (\forall n > N; f(n)\leq c \cdot g(n))$

  - $f(n) = O(g(n))\iff f(n)$ is eventually dominated by $g(n)$

- Big Omega Notation (lower bounds)

  - $f(n) = \Omega(g(n))\iff f(n)$ eventually dominates $g(n)$

- Big Theta Notation (tight bounds)

  - $\Theta(g(n)) = O(g(n)) \cap \Omega(g(n))$

> $\Theta(1)\approx\Theta(\log_2(n))<\Theta(\sqrt{n})<\Theta(n)\approx\Theta(n\log_2(n))<\Theta(n^2)<\Theta(n^3)<...<\Theta(2^n)<\Theta(n!)$

***Theorm 5.2*** Decision Problem

Every problem, for which the possible answers are **YES** or **NO** (or, **True** or **False**) can be interpreted as a language. 

$L_P=\{w \in \Sigma^*: w\ is\ an\ instance\ of\ the\ problem\ P\ whose\ answer\ is\ YES\}$

***Theorm 5.3*** Complexity Classes N vs NP

- Time Complexity 

  Given a (terminating) machine $M$, define a function $t_M:\Sigma^*\to\mathbb{N}$, then

  $t_M(w):=\{number\ of\ steps\ required\ to\ terminate\ on\ input\ w\in\Sigma^*\}$

  We define the **worst-case time** complexity as $t_M:\mathbb{N}\to\mathbb{N}$, then

  $t_M(w):=max\{t(w):all\ words\ w\ of\ length\ n\}$

- (Deterministic) Polynomial time

  A language $L$ is said to be solvable in **polynomial time** if there exists a **deterministic Turing Machine** $M$ such that

  1. $M$ accepts $L$, 
  2. $T_M \in O(n^k)$ is eventually dominated by a **polynomial function**. 

  $P = \{all\ problems\ decidable\ in\ polynomial\ time\}$

- Non-deterministic Polynomial time

  A langauge L is said to be solvable in **non-deterministic polynomial time** if there exists a **non-deterministic Turing Machine** $M$ such that

  1. $M$ accepts $L$, 
  2. $T_M \in O(n^k)$ is eventually dominated by a **polynomial function**. 

  $NP = \{all\ problems\ decidable\ in\ non-deterministic\ polynomial\ time\}$

> In other words, Polynomial time is like $O(1), O(\log(n)), O(n^a),...$ is acceptable for computer, while Non-polynomial time like $O(n!), O(a^n)$ not. Therefore, 
>
> $P$ are the questions that <u>can be solved</u> in polynomial time, and $NP$ are the questions that <u>their answers can be vertified</u> in polynomial time. 
>
> $NP$ includes $P$. 

---

#### 6. NP-Completeness

***Theorm 6.1.*** Computable Functions and Polynomial Reductions 

- A function $f:\Sigma^* \to \Sigma^*$ on words from $\Sigma^*$ is **computable** if there is a (deterministic) Turing Machine $M_f$ such that, 

  1. $M_f$ **accepts** all input words $w \in \Sigma^*$, 

  2. When **started** in configuration $(q_{init}, \epsilon, w)$ the machine eventually **terminates** in configuration $(q_{accept}, \epsilon, f(w))$. 

​	i.e., the machine terminates the contents of the tape from $w$ to $f(w)$ and returns the tape head to the start of the word. 

​	i.e., $f$ is computable in polynomial $\iff$ $f$ is **computable** if $M_f$ terminates in **polynomial-time**

- A **polynomial reduction** from a problem $X$ to a problem $Y$ is a function $f:\Sigma^* \to \Sigma^*$ **computable in polynomial-time** such that $w \in X \iff f(w) \in Y$. 

​	$X\leq_p Y$ means $X$ is polynomial reducible to $Y$. 

***Theorm 6.2.*** NP-hardness

A problem $X$ is said to be **NP-hard** if *every problem* in NP can be polynomial reduced to it. 

$Y\leq_p X$ for all $Y\in NP$ ($X$ is at least as hard as *every* NP-problem)

***Theorm 6.3.*** If $Y$ is NP-hard and $Y \leq_p X$, then $X$ is also NP-hard. 

***Proof.*** 

>Suppose that (i) $Y$ is NP-hard and (ii) $Y \leq_p X$, 
>
>By (i) we have that $Z \leq_p Y$ for all $Z \in NP$, 
>
>By (ii) and **transitivity** we have that $Z\leq_pY\leq_pX$ for all $Z \in NP$. 
>
>> A typical approach to demonstrating that a problem is **NP-hard** is to show that $SAT$ is reducible to it. i.e. that $SAT \leq_p X$.

***Theorm 6.4.*** NP-completeness

A problem $X$ is said to be **NP-complete** if (i) $X$ is **NP-hard** (lower bound) and (ii) $X$ also **belongs to NP** (upper bound). 

>e.g. Some examples of NP-complete problems
>
>The Boolean Statisfiability problem, The Clique problem, The Hamiltonian Cycle problem, ...
>
>Games like Lemmings or Pokemon, ...

---

#### 7. The Boolean Statisfiability Problem

***Theorm 7.1.*** The Boolean Satisfiability Problem **SAT**

**Input)** A propositional formula $F$. 

**Output)** **True** if and only if $F$ is *satisfiable* (Variables can be assigned so the formula is True). 

> | $P$  | $Q$  | $P \land Q$ |
> | :--: | :--: | :---------: |
> |  1   |  1   |  <u>1</u>   |
> |  1   |  0   |      0      |
> |  0   |  1   |      0      |
> |  0   |  0   |      0      |

***Theorm 7.2.*** Every formula is equivalent to a formula in DNF. 

***Proof.*** 

>1. Rewrite any <u>implications</u> which do not appear in DNF. 
>
>   $(F \to G) \implies (\neg F \vee G)$
>
>2. Use **De Morgan's Laws** to move the <u>negations</u> inside any brackets until they appear directly next to propositional variables. 
>
>   $\neg (F \land G) \implies (\neg F \vee \neg G), \neg (F \vee G) \implies (\neg F \land \neg G)$
>
>3. Eliminate any <u>double negations</u> with the **Cancellation Law**. 
>
>   $\neg \neg F \implies F$
>
>4. Apply the **Distributivity Laws** to bring any <u>disjunctions</u> to the 'surface'. 
>
>   $F \vee (G \land H) \implies (F \vee G)\land(F \vee H)$

***Theorm 7.3.*** Every formula is equivalent to a formula in CNF. 

***Proof.*** 

> Same as ***Proof. 7.2.*** 

***Theorm 7.4.*** The Boolean Satisfiability Problem **SAT** belongs to $NP$. 

***Proof.*** **Input)** Given formula $F$ in Conjunctive Normal Form. 

>1. We can decide whether $F$ is satisfiable by computing its truth table.
>
>   However the truth table contains $2^n$ rows, which is **NOT** polynomial. 
>
>2. However, a non-deterministic machine can evaluate each row in parallel. 
>
>   Each row requires us to evaluate at most $n$ boolean operators, which is polynomial. 
>
>3. QED. 

***Theorm 7.5.*** The Boolean Satisfiability problem **SAT** is **NP-complete**. 

---

#### 8. The Clique Problem

> ref: 
>
> [Prove that Clique problem is NP-Complete - Soptlog](https://soptq.me/2020/06/24/clique-npc/)

***Theorm 8.1.*** The Clique Problem **CLIQUE**

**Input)** An undirected graph $G=(V,E)$, an integer $k>2$. 

**Output)** $True$ if and only if $G$ contains a *clique* of size $k$. 

>  A *clique* of size k is an undirected graph that every distinct two vertices have a edge. 

***Theorm 8.2.*** The Clique Problem **CLIQUE** belongs to **NP**. 

***Proof.*** 

> Given an undirected graph $G=(V,E)$ and integer $k>2$, such that
>
> 1.  We can decide whether $G$ contains a clique of size $k$ by checking **every subset** of vertices of size $k$. However, there are $(^n_k)$ possible subsets, i.e., it is **NOT** polynomial! 
>
> 2. A non-deterministic machine can check each subset in **parallel**, each subset requires us to check only $k^2$ edges, which is polynomial. 

***Theorm 8.3.*** The Boolean Statisfiability problem is polynomially reducible to the Clique finding problem. i.e., **SAT**$\leq_p$**CLIQUE**

***Proof.*** 

>Given formula $F$ in Conjunctive Normal Form, 
>
>1. We want to construct a graph $G_F=(V,E)$ and choose an integer $k>2$, such that 
>
>   $F\ is\ satisfiable \iff G_F\ has\ a\ clique\ of\ size\ k$. 
>
>2. Define $G_F=(V,E)$ as follows: 
>
>   $F=(P \vee \neg Q \vee R)\land(\neg P \vee \neg Q \vee \neg R)\land(P \vee Q \vee \neg R)$
>
>3. Choose appropriate integer $k$ such that $k=\#clauses\ in\ F$
>
> 4. Hence, we have that: 
>
>  $F$ is satisfiable $\iff$ $G_F$ contains a clique of size $k$
>
>   **SAT** $\leq_p$ **CLIQUE**
>
> 5. QED. 

***Theorm 8.4.*** **CLIQUE** is **NP-complete**. 

---

#### 9. Hamiltonian Cycle Problem

***Theorm 9.1.*** The Hamiltonian Cycle Problem **HAMILTONIAN**

**Input)** An undirected graph $G=(V,E)$. 

**Output)** $True$ if and only if $G$ contains a *Hamiltonian Cycle*. 

> A *Hamiltonian cycle* is a graph cycle (i.e., closed loop) through a graph that **visits each node exactly once**. 

***Theorem 9.2.*** The Hamiltonian Cycle Problem **HAMILTONIAN** belongs to **NP**.

***Proof.*** 

> Given an undirected graph $G=(V, E)$, 
>
> 1. We can decide whether $G$ contains a Hamiltonian cycle by checking every permutation of the vertices. 
>
>    However there are $n!$ possible permutations, which is NOT polynomial. 
>
> 2. A NDTM can check each permutation with $n$ edges in parallel, which is polynomial. 

***Theorem 9.3.*** The Boolean Statisfiability problem is polynomially reducible to the Hamiltonian cycle problem. 

***Proof.*** 

> **Input)** Given a formula $F$ in Conjunctive Normal Form
>
> 1. We want to construct a graph $G_F$ such that
>
>    $F$ is statisfiable $\iff$ $G_F$ has a Hamiltonian cycle
>
> 2. We will make use of the following **gadget**: 4 vertices with 6 edges. 
>
> 3. Note that there are only two possible Hamiltonian Paths through the gadget. 
>
> 4. Assume $F=(P \land \neg Q) \vee (\neg P \vee \neg R)$ draw the figure. 
>
> 5. Hence, we have that
>
>    $F$ is statisfiable $\iff$ $G_F$ contains a Hamiltonian cycle
>
>    **SAT** $\leq_p$ **HAMILTONAIN**
>
> 6. QED. 

***Theorem 9.4.*** **HAMILTONIAN** is **NP-complete**. 

