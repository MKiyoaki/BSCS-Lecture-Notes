## WEEK III - SIMP & Abstract Machine

>[ðŸ  MENU - 5CCS2PLD](year2/5ccs2pld.md)
>
>[â¬…ï¸ WEEK II - Imperative Languages](year2/5ccs2pld/w2.md)
>
>[âž¡ï¸ WEEK IV - Induction & Structural Operational Semantics](year2/5ccs2pld/w4.md)
>
>Outlines:
>
>- SIMP
> - Abstract Machine

### 7. SIMP

##### 7.1. SIMP Introduction

- Definition
  - Formal description of the behaviour of programming constructs was in terms of an **abstract machine**. (An **abstract machine** is a transition system, which specifies an interpreter for the programming language.)
    
  - We will give start from a small imperative language: **SIMP**. 
  

##### 7.2. Syntax of the language SIMP

- Abstract Syntax

  - Programs

    - `P ::= C|E|B`

  - Commands

    - `C ::= skip|l := E|C ; C|if B then C else C | while B do C`

  - Integer Expressions

    - `E ::= !l|n|E op E`

    - `op ::= +|âˆ’|âˆ—|/`

    - where

      1. $n âˆˆ \mathbb{Z} = \{...,âˆ’2,âˆ’1,0,1,2,...\}$â€‹

      2. $l âˆˆ L = \{l_0, l_1, . . .\} \text{ (locations or variables)}$

      3. The expression $!l$ denotes the value stored in $l$

  - Boolean Expressions

    - `B ::= True|False|E bop E|Â¬B|B âˆ§ B`
    - `bop ::= >|<|=`

  > e.g. 
  >
  > Swapping the contents of the variables $x$ and $y$â€‹
  >
  > `z := !x ; x := !y ; y := !z`
  >
  > Factorial
  >
  > >Assuming the variable l contains a natural number $n$, the following program computes the factorial of $n$
  > >
  > >```
  > >factorial := 1; 
  > >while !l > 0 do
  > >	(factorial := !factorial âˆ— !l; 
  > >	l := !l âˆ’ 1)
  > >```

- Syntax Tree

  - The grammars specify the abstract syntax of SIMP, therefore rules specify labelled trees rather than strings. 
  - The leaf nodes of the tree are labelled by elements of $Z âˆª \{\text{True, False}\} âˆª L âˆª \{\text{skip}\}$â€‹ while the non-leaf nodes are labelled by operators and commands. 

  > e.g.
  >
  > ```mermaid
  > graph TB
  > 	A((if-then-else))
  > 	B1((>))
  > 	B2((skip))
  > 	B3((;))
  > 	B1C1((5))
  > 	B1C2((0))
  > 	B3C1((skip))
  > 	B3C2((:=))
  > 	B3C2D1((1))
  > 	B3C2D2((0))
  > 	
  > 	A---B1
  > 	A---B2
  > 	A---B3
  > 	B1---B1C1
  > 	B1---B1C2
  > 	B3---B3C1
  > 	B3---B3C2
  > 	B3C2---B3C2D1
  > 	B3C2---B3C2D2
  > ```
  >
  > is written in a textual notation as `if 5>0 then skip else (skip; l := 0)`, using brackets where there is ambiguity.


---

### 8. An Abstract Machine for SIMP

##### 8.1. Definition

- We will define an abstract machine with

  1. a **control stack** $c$

  2. an **auxiliary stack** $r$â€‹, also called **results stack**

  3. **memory**, also called **store**, modelled by a partial function $m$, mapping each address to an integer. $dom(m)$ denotes the locations where $m$â€‹ is defined.

  >Notation:
  >
  >$m[l \mapsto n]$ is the function that maps each $l' \neq l$ to the value $m(l')$, and $l$ to the value $n$. 
  >
  >More precisely, 
  >
  >$m[l \mapsto n](l) = n$ 
  >
  >$m[l \mapsto n](l') = m(l') \text{ if }l \neq l'$â€‹

##### 8.2. Configurations - A triple $âŸ¨\text{Control, Results, Memory}âŸ©$â€‹

- Definition of the control and results stacks:

  - `c ::= nil|i Â· c`
  - `i ::= P|op|Â¬|âˆ§|bop| :=|if|while`
  - `r ::= nil |P Â· r|l Â· r`

  where `P`, `bop` and `op` are the non-terminals used in the rules defining SIMP programs.

- To model the execution of a program we will define transitions between initial and final configurations.

  - Initial Configurations - $âŸ¨C Â· \text{nil,nil},mâŸ©$
  - Final Configurations - $âŸ¨\text{nil, nil}, mâŸ©$

- Semantics

  - If there is a sequence of transitions

    $(CÂ·\text{nil,nil},m) \longrightarrow^âˆ— (\text{nil,nil},m')$

    - then we say that <u>the program $C$ executed in the state $m$ terminates successfully producing the state $m'$</u>. 
    - The semantics of a command $C$ in the state $m$ is described by giving the sequence of transitions that transform the configuration $(C Â· \text{nil, nil}, m)$ into $(\text{nil, nil}, mâ€²)$.

  - If there is a sequence of transitions

    $(E Â· c , r , m) \longrightarrow^âˆ— (c , v Â· r , m') \\ (B Â· c , r , m) \longrightarrow^âˆ— (c , v Â· r , m')$

    Then we say that <u>the value of the expression $E (\text{resp.} B)$ in the state $m$ is $v$â€‹</u>.

##### 8.3. Transition Rules

- Definition

  - A transition rule has the form $c â†’ c'$, where $c$ and $c'$â€‹ describe configurations.
  - The transition rules generate the transition relation.
  - We divide the rules in two groups: 
    1. rules for the evaluation of expressions and 
    2. rules for the evaluation of commands.

- Example

  >Evaluation of expressions:
  >
  >- $âŸ¨nÂ·c,r,mâŸ© \to âŸ¨c,nÂ·r,mâŸ©$â€‹
  >- $âŸ¨bÂ·c,r,mâŸ© \to âŸ¨c,bÂ·r,mâŸ©$
  >- $âŸ¨Â¬BÂ·c,r,mâŸ© \to âŸ¨BÂ·Â¬Â·c,r,mâŸ©$â€‹
  >- $âŸ¨(B_1 \wedge B_2)Â·c,r,mâŸ© \to âŸ¨B_1Â·B_2Â·\wedgeÂ·c,r,mâŸ©$â€‹
  >- $âŸ¨Â¬Â·c,bÂ·r,mâŸ© \to âŸ¨c,b'Â·r,mâŸ© \text{ if }b' =! b$â€‹
  >- $âŸ¨\wedgeÂ·c,b_2Â·b_1Â·r,mâŸ© \to âŸ¨c,bÂ·r,mâŸ© \text{ if }b_1 \wedge b_2 = b$â€‹â€‹
  >- $âŸ¨(E_1\ op\ E_2)Â·c, r, mâŸ© \rightarrow âŸ¨E_1 Â· E_2 Â· op Â·c, r, mâŸ©$â€‹
  >- $âŸ¨(E_1\ bop\ E_2)Â·c, r, mâŸ© \rightarrow âŸ¨E_1 Â· E_2 Â· bop Â·c, r, mâŸ©$
  >- $âŸ¨opÂ·c,bÂ·r,mâŸ© \to âŸ¨c,nÂ·r,mâŸ© \text{ if } n_1 \text{ op } n_2 = n$â€‹
  >- $âŸ¨bopÂ·c,bÂ·r,mâŸ© \to âŸ¨c,bÂ·r,mâŸ© \text{ if } n_1 \text{ bop } n_2 = b$â€‹
  
  >e.g.
  >
  >Assume $m = \{l \mapsto 4\}$ and we want to evaluate the expression $!l > 0$â€‹.
  >
  >- **Initial configuration** - $âŸ¨!l > 0 Â· \text{nil , nil} , mâŸ©$â€‹â€‹
  >>>
  >  $âŸ¨!l>0Â·\text{nil,nil},mâŸ© \to âŸ¨!lÂ·0Â·>Â·\text{nil,nil},mâŸ© $
  >>>
  >  $\to âŸ¨0Â·>Â·\text{nil},4Â·\text{nil},mâŸ©$ 
  >>>
  >  $\to âŸ¨>Â·\text{nil},0Â·4Â·\text{nil},mâŸ©$ 
  >>>
  >  $ \to âŸ¨\text{nil,TrueÂ·nil},mâŸ©$
  >
  >- The machine reached a final configuration, thus, the expression $!l > 0$ evaluates to **True** in the given memory state.
  
- The abstract machine can describe the exact behaviour of a *while loop*. 

  > Compare with the informal definition: *... the body of the loop is executed as long as the value of the expression is true.*

##### 8.4. Operational Semantics

- Evaluation on the Abstract Machine

  - Pros - The abstract machine explains the execution of the commands step by step, which is useful if we have to implement the language.
  - Cons - It is not very intuitive. Many transitions are doing just phrase analysis, only a few really perform computations.

- Structural Approach to Operational Semantics

  - To overcome the previous problem, another approach to operational semantics based on transition systems was developed: the structural approach (Plotkin).

  - Idea: The transitions for a compound statement should be defined in terms of the transitions for its constituent sub-statements.

    > i.e., the definition should be **inductive**.