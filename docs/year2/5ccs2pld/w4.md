## WEEK IV - Induction & Structural Operational Semantics

>[ðŸ  MENU - 5CCS2PLD](year2/5ccs2pld.md)
>
>[â¬…ï¸ WEEK III - SIMP & Abstract Machine](year2/5ccs2pld/w3.md)
>
>[âž¡ï¸ WEEK V - ](year2/5ccs2pld/w5.md)
>
>Outlines:

### 9. Recap for Induction

##### 9.1. The Principle of Mathematical Induction

- Induction

  - For any property $P(n)$ of natural numbers *(i.e. $n âˆˆ \mathbb{N} = \{0,1,2,...\}$)*, to prove $âˆ€n âˆˆ \mathbb{N}.P(n)$â€‹ it is sufficient to show that

    - Base Case: $P(0)$
    - Induction Step: $âˆ€n âˆˆ \mathbb{N} .P(n) \implies P(n + 1)$â€‹â€‹


  > e.g.
  >
  > We prove that for all natural numbers $n$ that $\Sigma^n_{i=1}(2i-1)=n^2$
  >
  > - Base: $0=0^2$
  >
  > - Induction: 
  >
  >   Assume $\Sigma^n_{i=1}(2i-1)=n^2$â€‹â€‹
  > 
  >   $\Sigma^{n+1}_{i=1}(2i-1)=\Sigma^n_{i=1}(2i-1)+2(n+1)-1=n^2+2n+1=(n+1)^2$

- Structural Induction

  - We denote an empty list by $\text{nil}$, and a non-empty list by $\text{cons}(h,l)$ where $h$ is the head element and $l$ is the tail of the list.
  - To prove that a property $P$ holds for every list, it is sufficient to prove that
    - Base Case: $P(\text{nil})$
    - Induction Step: $P(l) \implies P(\text{cons}(h,l)) \text{ for all }h, l$â€‹  
  - More generally, if we are working with finite labelled trees and we want to prove a property $P$ for those trees, it is sufficient to show that
    - Base Case: $P(l)$ for all leaf nodes $l$
    - Induction Step: for each tree constructor $c (\text{with } n â‰¥ 1 \text{ arguments}): âˆ€t_1, . . . , tn.P(t_1) âˆ§ ... âˆ§ P(t_n) â‡’ P(c(t_1, ... , t_n))$â€‹

  > e.g.
  >
  > To prove that a property $P$â€‹ holds for all integer expressions in SIMP
  >
  > - Base: 
  >   - Prove $P(n) \text{ for all } nâˆˆ\mathbb{Z}$â€‹
  >   - Prove $P(!l) \text{ for all locations }l$
  > - Induction: 
  >   - For all integer expressions $E, E'$ and operators $op$, Prove that $P(E), P(E') \implies P(E\ op\ E')$

- Remark

  - The principle of structural induction can be justified by the principle of mathematical induction. 
  - This is because we work with *finite* trees, so we can understand structural induction as induction on the *size* of the tree.


##### 9.2. Application of the Structural Induction Principle

- Property
  - The semantics of SIMP guarantees that for any integer expression $E$ appearing in a program working on a memory $m$, if $E$ uses locations that are defined in $m$ then the value of $E$â€‹ is defined.
  - i.e., For any configuration $âŸ¨E Â· c , r , mâŸ©$ where $c$ is any arbitrary control stack and $r$ is also arbitrary, there is a configuration $âŸ¨c,nÂ·r,mâŸ©$ such that $âŸ¨EÂ·c,r,mâŸ© \rightarrow^âˆ— âŸ¨c,nÂ·r,mâŸ©$â€‹.

  > *Proof.* 
  >
  > $âˆ€E.P(E)  \text{ where } P \text{ is}$
  >
  > $âˆ€m.\text{locations}(E) âˆˆ dom(m) \implies âˆƒn.âˆ€c.âˆ€r.âŸ¨EÂ·c,r,mâŸ© \rightarrow^âˆ— âŸ¨c,nÂ·r,mâŸ©$â€‹
  >
  > We have to prove by induction on the structure of $E$â€‹ that
  >
  > 1. Base Case: If $E$ is a number $n$ or $!l$ then the transitions for constants and locations prove $P(E)$.
  >
  > 2. Induction Step: 
  >
  >    - Assume $P(E_1)$ and $P(E_2)$ hold, we have to prove $P(E_1\ op\ E_2)$â€‹.
  >
  >    - $âŸ¨(E_1\ op\ E_2)Â·c,r,mâŸ© \rightarrow âŸ¨E_1 Â·E_2 Â·opÂ·c,r,mâŸ©$ 
  >
  >      $\rightarrow^âˆ—âŸ¨E_2Â·opÂ·c,n_1Â·r,mâŸ© \text{ for some } n_1 \text{ by } P(E_1)$ 
  >
  >      $\rightarrow^âˆ—âŸ¨opÂ·c,n_2Â·n_1Â·r,mâŸ© \text{ for some } n_2 \text{ by } P(E_2)$
  >
  >      $\rightarrow^âˆ— âŸ¨c,nÂ·r,mâŸ© \text{ where } n = n_1\ op\ n_2$â€‹

##### 9.3. Inductive Definitions

- Definition

  > We can also use induction to define subsets of a given set $T$â€‹. We will write inductive definitions using axioms (representing the base case) and rules (representing the induction step).

  - An axiom is an element of $T$
  - A rule is a pair $(H,c)$â€‹ where
    - $H$ is a non-empty subset of $T$â€‹, called the **hypotheses** of the rule
    - $c$ is an element of $T$â€‹, called the conclusion of the rule.
  - The subset $I$ of $T$ inductively defined by a collection of axioms $A$ and rules $R$ consists of those $t âˆˆ T$â€‹ such that
    - $t âˆˆ A$, or
    - there are $t_1,...,t_n âˆˆ I$ and a rule $(H,c)$ such that $H = {t_1,...,t_n}$ and $t = c$

  > *Proof.* 
  >
  > To show that an element $t$ of $T$ is in $I$ it is sufficient to show that $t$ is an axiom, or that there is a proof
  >
  > ```mermaid
  > graph TB
  > 	A((t))
  > 	B1((t1))
  > 	B2((tn))
  > 	B1C1((t11))
  > 	B1C2((t1m1))
  > 	B2C1((tn1))
  > 	B2C2((tnmn))
  > 
  > 	A---B1
  > 	A---B2
  > 	B1---B1C1
  > 	B1---B1C2
  > 	B2---B2C1
  > 	B2---B2C2
  > ```
  >
  > where the leaves are axioms and for each non-leaf node ti there is a rule $({t_{i1},...,t_{im_{i}} },t_i)$â€‹.

- Examples

  >e.g.1.
  >
  >

##### 9.4. 





---

### 10. Small-Step Operational Semantics for SIMP



---

### 11. Big-Step Semantics for SIMP